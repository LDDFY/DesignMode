### 单例模式

#### 概述：
> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。



**优点**：

    1. 在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就 防止其它对象对自己的实例化，确保所有的对象都访问一个实例 
    2. 单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。 
    3. 提供了对唯一实例的受控访问。 
    4. 由于在系统内存中只存在一个对象，因此可以节约系统资源，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。 
    5. 允许可变数目的实例。 
    6. 避免对共享资源的多重占用。

**缺点**：

    1. 不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。 
    2. 由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。 
    3. 单例类的职责过重，在一定程度上违背了“单一职责原则”。 
    4. 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出。 

#### 实现方式：

* [饿汉式](EagerSingleton.java)
* [懒汉式](LazySingleton.java)
* [双检索（DCL）](DCLSingleton.java)
* [占位符式}](PlaceholderSingleton.java)
* [枚举式](EnumSingleton.java)

#### 各种实现方式的优缺点
* 饿汉式：饿汉模式在类加载的时候就对实例进行创建，实例在整个程序周期都存在。它的好处是只在类加载的时候创建一次实例，不会存在多个线程创建多个实例的情况，避免了多线程同步的问题。它的缺点也很明显，即使这个单例没有用到也会被创建，而且在类加载之后就被创建，内存就被浪费了，当一个系统中存在大量此模式单例并且单例处理业务比较负责时启动会变慢。

* 懒汉式：效率低，第一次加载需要实例化，反应稍慢。不加锁首次调用方法可能会存在线程安全问题出现多个实例对象，如果加锁会导致请求排队消耗不必要的资源。

* 双检索：懒汉模式的优化版本,使用volite和synchronized解决了线程安全性问题，但是使用了volite关键字导致性能不如普通懒汉模式。

* 占位符式：使用内部类实现，外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化实例，故而不占内存。即当单例第一次被加载时，并不需要去加载静态内部类，只有当方法第一次被调用时虚拟机才会加载内部类并且只加载一次，同时静态内部类又不会被JVM回收，因此这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化。
 
* 枚举式：代码简单不需要考虑序列化时候单例被破坏，能够预防反射攻击造成实例不一致，缺点不能懒加载。     

#### 总结

```饿汉式```、```懒汉式```、```双检索```、```占位符式```单例在使用时候除了要考虑各自优缺点外还要考虑处理由于反射造成的破坏（改造构造方法）、以及序列化破坏（重写readResolve方法）等情况;```枚举式```单例除不能懒加载外，不存在上述其他问题。推荐使用
