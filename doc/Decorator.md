### 装饰者模式
#### 概述
>装饰模式指的是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。

#### 涉及角色
1. 抽象构件角色（Component）：给出一个抽象接口，以规范准备接受附加责任的对象。
2. 具体构件角色（ConcreteComponent）：定义一个将要接收附加责任的类。
3. 装饰角色（Decorator）：持有一个构件（Component）对象的实例，并定义一个与抽象构件接口一致的接口。
4. 具体装饰角色（ConcreteDecorator）：负责给构件对象“贴上”附加的责任。

#### 适用场景
1. 需要扩展一个类的功能，或给一个类添加附加职责。
2. 需要动态的给一个对象添加功能，这些功能可以再动态的撤销。
3. 需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。
4. 当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。

#### 优缺点
##### 优点：
1. 通过组合而非继承的方式，实现了动态扩展对象的功能的能力。
2. 有效避免了使用继承的方式扩展对象功能而带来的灵活性差，子类无限制扩张的问题。
3. 充分利用了继承和组合的长处和短处，在灵活性和扩展性之间找到完美的平衡点。
4. 装饰者和被装饰者之间虽然都是同一类型，但是它们彼此是完全独立并可以各自独立任意改变的。
5. 遵守大部分GRAP原则和常用设计原则，高内聚、低偶合。

##### 缺点：
1. 装饰链不能过长，否则会影响效率。
2. 因为所有对象都是继承于Component,所以如果Component内部结构发生改变，则不可避免地影响所有子类(装饰者和被装饰者)，也就是说，通过继承建立的关系总是脆弱地，如果基类改变，势必影响对象的内部，而通过组合建立的关系只会影响被装饰对象的外部特征。
3. 只在必要的时候使用装饰者模式，否则会提高程序的复杂性，增加系统维护难度。
 
### 示例代码

### 实例
 