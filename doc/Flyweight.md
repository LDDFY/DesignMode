### 享元模式
#### 概述
> 运用共享技术有效的支持大量细粒度的对象。享元模式采用一个共享来避免大量拥有相同内容对象的开销。这种开销最常见、最直观的就是内存的消耗。
> 享元对象能做到共享的关键是区分内蕴状态（Internal State）和外蕴状态（External State）。
> 一个内蕴状态是存储在享元对象内部的，并且是不会随环境的改变而有所不同。因此，一个享元可以具有内蕴状态并且可以共享。
> 一个外蕴状态是随环境的改变而改变的、不可以共享的。享元对象的外蕴状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。
> 外蕴状态不可以影响享元对象的内蕴状态，他们是相互独立的。
> 享元模式可以分成单纯享元模式和复合享元模式

#### 单纯享元模式角色
1. 抽象享元角色(flyWeight)：为具体享元角色规定了必须实现的方法，而外蕴状态就是以参数的形式通过此方法传入。在Java中可以由抽象类、接口来担当。
2. 具体享元角色(concreteFlyWeight)：实现抽象角色规定的方法。如果存在内蕴状态，就负责为内蕴状态提供存储空间。
3. 享元工厂角色(flyWeightFactory)：负责创建和管理享元角色。要想达到共享的目的，这个角色的实现是关键！
4. 客户端角色(client)：维护对所有享元对象的引用，而且还需要存储对应的外蕴状态。

#### 复合享元模式角色
1. 抽象享元角色（Flyweight）：给出一个抽象接口，以规定出所有具体享元角色需要实现的方法。
2. 具体享元角色（ConcreteFlyweight)：实现抽象享元角色所规定出的接口。如果有内蕴状态的话，必须负责为内蕴状态提供存储空间。
3. 复合享元角色（ConcreteCompositeFlyweight)：复合享元橘色所代表的对象是不可以共享的，但是一个复合享元对象可以分解成为多个本身是单纯享元对象的组合。复合享元角色又称作不可共享的享元对象。
4. 享元工厂角色（FlyweightFactory)：本角色负责创建和管理享元角色。本橘色必须保证享元对象可以被系统适当地共享。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否已经有一个符合要求的享元对象。如果已经有了，享元工厂角色就应当提供这个已有的享元对象；如果系统中没有一个适当的享元对象的话，享元工厂角色就应当创建一个合适的享元对象。
5. 客户端角色(client)：维护对所有享元对象的引用，而且还需要存储对应的外蕴状态。

#### 示例代码
1. [单纯享元模式](../src/flyweight/simple/FlyWeightTest.java)
2. [复合享元模式](../src/flyweight/composite/CompositeFlyWeightTest.java)

#### 应用实例
1. java String 常量池。
2. java.lang.Integer#valueOf(int)
3. java.lang.Boolean#valueOf(boolean)
4. java.lang.Byte#valueOf(byte)
5. java.lang.Character#valueOf(boolean)
