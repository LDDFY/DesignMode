#### 适配器模式

#### 概述
> 将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

####角色分类
1. Target:目标对象。
2. Adaptee:被适配对象。
3. Adapter:适配器。

#### 分类
1. [对象适配器](../src/adapter/object/ObjectAdapter.java):对象适配器使用对象组合的方式，是动态组合的方式。对于对象适配器，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。
                                                     对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。对于对象适配器，需要额外的引用来间接得到Adaptee。
2. [类适配器](../src/adapter/clazz/Adapter.java):
类适配器使用对象集成的方式，是静态的定义方式；对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不能再取处理Adaptee的子类了。对于类适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。
3. [默认适配器](../src/adapter/dft/LiveTarget.java): 当你想实现一个接口但又不想实现接口中所有的方法，只想去实现一部分方法时，就用到了默认适配器模式。它的方法时在接口和具体实现类中添加一个抽象类，而用抽象类是实现目标接口的所有方法。而具体的实现类只需要覆盖其需要完成的方法即可。

#### 优点
1. 将目标类和适配者类解耦
2. 增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性
3. 灵活性和扩展性都非常好，符合开闭原则

#### 适用场景
1. 接口中规定了所有要实现的方法
2. 但一个要实现此接口的具体类，只用到了其中的几个方法，而其它的方法都是没有用的。

#### 总结
建议尽量使用对象适配器的实现方式，符合CARP原则。