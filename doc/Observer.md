### 观察者模式
#### 概述
>观察者设计模式定义了对象间的一种一对多的组合关系，以便一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动刷新。

#### 角色
1. 抽象主题角色(Subject)：把所有对观察者对象的引用保存在一个集合中，每个抽象主题角色都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。
2. 具体主题角色(ConcreteSubject)：在具体主题内部状态改变时，给所有登记过的观察者发出通知。具体主题角色通常用一个子类实现。
3. 抽象观察者角色（Observer）：为所有的管擦着定义一个接口，在得到主题的通知更新自己。
4. 具体观察者角色(ConcreteObserver)：该角色实现抽象观察者角色所要求的更新接口，以便使本身的状态和主题的状态相协调。通常用一个子类实现。如果需要，具体观察者角色可以保持一个指向具体主题角色的引用。
 
#### 示例代码
1. [推模式](../src/observer/push/ObserverTest.java)
2. [拉模式](../src/observer/pull/ObserverTest.java)

#### 两种模式比较：
  推模型假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己取按需要取值。 推模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。

#### 优缺点
#### 优点：
1. Subject和Observer之间是松耦合的，分别可以各自独立改变。
2. Subject在发送广播通知的时候，无需指定具体的Observer,Observer可以自己决定是否要订阅Subject的通知。

#### 缺点：
2. 松耦合导致代码关系不明显，有时可能难以理解
2. 如果一个Subject被大量Observer订阅的话，在广播通知的时候可能会有效率问题。
 
#### 应用实例
1. java.util.EventListener
2. javax.servlet.http.HttpSessionBindingListener
3. javax.servlet.http.HttpSessionAttributeListener
4. javax.faces.event.PhaseListener
 